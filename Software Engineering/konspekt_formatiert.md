# Konspekt: Software-Engineering

## 1. Ursachen fÃ¼r Softwarefehler

### 1.1 Steigende Anforderungen

Neue Technologien ermÃ¶glichen komplexere Systeme. Dadurch steigen auch die Anforderungen:

- Systeme mÃ¼ssen schneller entwickelt, leistungsfÃ¤higer und komplexer werden.
- Die bisherigen SE-Methoden reichen dafÃ¼r oft nicht aus â€“ neue Techniken sind nÃ¶tig.

### 1.2 Geringe Erwartungen

Viele Programme werden ohne Anwendung von SE-Methoden geschrieben. Firmen, die Software neu integrieren, nutzen SE-Methoden im Alltag kaum.

- Folge: teure und unzuverlÃ¤ssige Software.
- LÃ¶sung: bessere Ausbildung im Bereich SE.

## 2. Geschichte des Software-Engineerings

Der Begriff **â€Software-Engineeringâ€œ** wurde 1968 auf einer Konferenz geprÃ¤gt, die sich mit der â€Softwarekriseâ€œ beschÃ¤ftigte.

Damals zeigte sich, dass individuelle ProgrammieransÃ¤tze fÃ¼r groÃŸe Systeme ungeeignet waren:

- UnzuverlÃ¤ssig
- Teuer
- VerspÃ¤tet

In den 1970er und 1980er Jahren entstanden neue Techniken:

- Strukturierte Programmierung
- Datenkapselung (Information Hiding)
- Objektorientierte Entwicklung

Werkzeuge und Notationen wurden entwickelt und sind heute weit verbreitet.

## 3. Fragen & Antworten zum Software-Engineering

**Was ist Software?**  
â†’ Computerprogramme und zugehÃ¶rige Dokumentation fÃ¼r Kunden oder den Markt.

**Eigenschaften guter Software:**  
â†’ Funktional, performant, wartbar, zuverlÃ¤ssig und nÃ¼tzlich.

**Was versteht man unter Software-Engineering?**  
â†’ Technische Disziplin fÃ¼r alle Aspekte der Softwareherstellung.

**Grundlegende AktivitÃ¤ten:**  
â†’ Softwarespezifikation, -entwicklung, -validierung, -weiterentwicklung.

**Unterschied zur Informatik:**  
â†’ Informatik = Theorie, SE = Praxis und nutzbare Software.

**Unterschied zu Systems Engineering:**  
â†’ Systems Engineering = Hard-, Soft- und Prozessentwicklung.  
â†’ Software-Engineering ist ein Teil davon.

**GrÃ¶ÃŸte Herausforderungen:**  
â†’ VielfÃ¤ltige Anforderungen, kurze Lieferzeiten, zuverlÃ¤ssige Softwareentwicklung.

## 4. Was gehÃ¶rt zur Software im SE?

Neben Programmen auch:

- zugehÃ¶rige Dokumentation
- Konfigurationsdaten

**Professionelle Software umfasst:**

- mehrere Programme und Konfigurationsdateien
- System- und Benutzerdokumentation
- Update-Websites

**Unterschiede:**

- *Amateurhafte Entwicklung:* keine Doku, nur fÃ¼r Eigengebrauch  
- *Professionelle Entwicklung:* Doku & Quellcode erforderlich

## 5. QualitÃ¤tsmerkmale professioneller Software

Nicht nur Funktion, sondern auch:

- Verhalten
- Struktur
- Dokumentation

### 5.1 Nicht-funktionale Merkmale

- Antwortzeit
- VerstÃ¤ndlichkeit des Codes

### 5.2 Anwendungsspezifisch

- Bank: Sicherheit
- Spiel: ReaktionsfÃ¤higkeit
- Vermittlungssystem: ZuverlÃ¤ssigkeit

### 5.3 Allgemeine Merkmale

- **Wartbarkeit:** leicht anpassbar
- **VerlÃ¤sslichkeit & Sicherheit:** zuverlÃ¤ssig, bei Ausfall keine SchÃ¤den
- **Effizienz:** Ressourcenschonung (Antwortzeit, Speicherverbrauch)
- **Akzeptanz:** verstÃ¤ndlich, nÃ¼tzlich, integrierbar

## 6. Definition von Software-Engineering

Technische Disziplin fÃ¼r alle Phasen der Softwareentwicklung â€” von der Spezifikation bis zur Wartung.

### 6.1 Zwei SchlÃ¼sselbegriffe

**Technische Disziplin:**  
Einsatz von Theorien, Methoden und Werkzeugen unter realistischen Bedingungen.

**Alle Aspekte der Softwareherstellung:**  
Nicht nur Technik, sondern auch Projektmanagement, Methoden- und Prozessentwicklung.

**Ziel:** QualitÃ¤t, Zeit und Budget einhalten.

## 7. Softwareprozess

Systematischer Ansatz mit vier KernaktivitÃ¤ten:

1. **Softwarespezifikation** â€“ Anforderungen definieren  
2. **Softwareentwicklung** â€“ Entwurf und Implementierung  
3. **Softwarevalidierung** â€“ PrÃ¼fung der Anforderungen  
4. **Softwareevolution** â€“ Weiterentwicklung nach Bedarf  

*Hinweis:* Verschiedene Softwaretypen â†’ unterschiedliche Prozesse.

## 8. Herausforderungen moderner Software

- **HeterogenitÃ¤t:** Unterschiedliche Plattformen, GerÃ¤te und Netzwerke  
- **Wandel:** Wirtschaft und Gesellschaft Ã¤ndern sich schnell  
- **Sicherheit & Vertrauen:** Schutz bei verteilten Systemen und Benutzersicherheit  

## 9. Anwendungstypen

- **EigenstÃ¤ndige Anwendungen:** lokal, ohne Netzwerk (z. B. Office, CAD)  
- **Interaktive transaktionsbasierte Anwendungen:** client-server, web-basiert  
- **Eingebettete Steuerungssysteme:** GerÃ¤te wie Auto oder Haushalt  
- **Stapelverarbeitungssysteme:** Massendaten (z. B. Gehaltsabrechnung)  
- **Unterhaltungssysteme:** Spiele, Streaming etc.  
- **Simulation/Modellierungssysteme:** wissenschaftlich-technische Nutzung  
- **Datenerfassungssysteme:** Sensorik in rauer Umgebung  
- **Systeme von Systemen:** Integration mehrerer Teilsysteme  

## 10. Ethische Prinzipien (ACM/IEEE)

Softwareentwickler sollen Analyse, Entwurf, Test und Wartung verantwortungsvoll betreiben.

**8 Prinzipien:**

1. **Ã–ffentlichkeit** â€“ im Ã¶ffentlichen Interesse handeln  
2. **Kunde & Arbeitgeber** â€“ LoyalitÃ¤t im Rahmen des Gemeinwohls  
3. **Produkt** â€“ hÃ¶chste professionelle Standards  
4. **Beurteilung** â€“ IntegritÃ¤t und UnabhÃ¤ngigkeit  
5. **Management** â€“ ethisch verantwortliches Projektmanagement  
6. **Beruf** â€“ IntegritÃ¤t und Ansehen fÃ¶rdern  
7. **Kollegen** â€“ fairer und hilfsbereiter Umgang  
8. **Selbst** â€“ lebenslanges Lernen und ethisches Vorbild  

## 11. Fallstudien

### 11.1 Eingebettetes System

- Software zur Steuerung eines GerÃ¤ts (z. B. medizinische Pumpe)  

### 11.2 Informationssystem

- Verwaltung sensibler Patientendaten (Sicherheit, Datenschutz, Benutzerfreundlichkeit)  

## 12. Vorgehensmodelle

### 12.1 Definition

Ein Vorgehensmodell ist eine vereinfachte Darstellung eines Softwareprozesses.  

### 12.2 Wasserfallmodell

Lineare Phasen:

1. Anforderungsdefinition  
2. System- und Softwareentwurf  
3. Implementierung und Modultests  
4. Integration und Systemtests  
5. Betrieb und Wartung  

### 12.3 Inkrementelle Entwicklung

- Entwicklung in mehreren Versionen (Inkrementen)  
- Kombination aus Spezifikation, Entwicklung und Validierung  

### 12.4 Wiederverwendungsorientiertes SE

- Nutzung vorhandener Komponenten  
- Fokus auf Integration statt Neuentwicklung  

### 12.5 Modellkombination

- Wasserfallmodell fÃ¼r stabile Teile  
- Inkrementell fÃ¼r unklare oder UI-bezogene Teile  

> **Hinweis:** Modelle lassen sich kombinieren â€“ besonders bei groÃŸen Systemen sinnvoll.  

### 12.6 Praxis und Probleme des Wasserfallmodells

- **PhasenÃ¼berlappung:** Informationsaustausch zwischen Phasen fÃ¼hrt zu RÃ¼ckkopplungen.  
- **Hohe Dokumentationskosten:** Phasen werden schnell â€eingefrorenâ€œ.  
- **Risiko des verfrÃ¼hten Einfrierens:** Anforderungen zu frÃ¼h fixiert.  
- **Problemumgehung:** Entwurfsfehler werden durch â€Tricksâ€œ im Code gelÃ¶st.  
- **Betrieb und Wartung:** Weitere Fehler und Bedarf an neuer FunktionalitÃ¤t.  

### 13.1 Inkrementelle Entwicklung (detailliert)

1. Erstellung einer Anfangsversion  
2. Feedback der Benutzer  
3. Zwischenversionen und iterative Verbesserungen  
4. Endversion erfÃ¼llt Anforderungen  

**Vorteile:**  

- Reduzierte Kosten fÃ¼r Ã„nderungen  
- Schnellere RÃ¼ckmeldung  
- FrÃ¼hzeitige Auslieferung  

**Nachteile:**  

- Geringe Prozesssichtbarkeit  
- SchwÃ¤chere Systemstruktur bei hÃ¤ufiger Ã„nderung  
- Koordinationsaufwand in groÃŸen Systemen  
- Inkrementelle Auslieferung kann GeschÃ¤ftsprozesse stÃ¶ren  
- BÃ¼rokratische Organisationen erschweren Iteration  

### 13.2 Wiederverwendungsorientierter Prozess (Stufen)

1. Analyse vorhandener Komponenten  
2. Anpassung der Anforderungen  
3. Systementwurf mit Wiederverwendung  
4. Entwicklung und Integration  

**Komponentenarten:**  

- Webdienste  
- Objektsammlungen (Pakete)  
- EigenstÃ¤ndige Systeme (z. B. COTS)  

**Vorteile:**  

- Reduzierung von Aufwand, Kosten und Risiken  
- Schnellere Lieferung  

**Nachteile:**  

- Kompromisse bei Anforderungen  
- Verlust der Kontrolle Ã¼ber Komponenten  

### 13.3 V-Modell

Vorgehensmodell fÃ¼r IT-Projekte der Ã¶ffentlichen Verwaltung in Deutschland.

Phasen:

1. Definition der Anforderungen  
2. Funktionales Systemdesign  
3. Technisches Systemdesign  
4. Spezifikation der Komponenten  
5. Implementierung  
6. Komponententest  
7. Integrationstest  
8. Systemtest  
9. Akzeptanz

#### CASE-Werkzeuge: Programme zur UnterstÃ¼tzung von Softwareprozessen.

Beispiele fÃ¼r automatisierte AktivitÃ¤ten:

- grafische Systemmodelle entwickeln,

- Code aus Modellen erzeugen,

- BenutzeroberflÃ¤chen grafisch erzeugen,

- Fehlerbehebung durch Debugging,

- automatische Ãœbersetzung alter Programmiersprachenversionen.

### Softwarespezifikation â€“ Zusammenfassung
Ziel: Funktionen und EinschrÃ¤nkungen des Systems verstehen und definieren.

Kritische Phase â€“ Fehler fÃ¼hren spÃ¤ter zu Problemen.

Ergebnis: gemeinsames Anforderungsdokument.

Zwei Ebenen:

- grobe Anforderungen fÃ¼r Nutzer/Kunden,
- detaillierte Spezifikation fÃ¼r Entwickler.

### Ablauf der Anforderungsanalyse â€“ Ãœbersicht
Vier HauptaktivitÃ¤ten:

1. DurchfÃ¼hrbarkeitsstudie: Machbarkeit, Wirtschaftlichkeit und Budget prÃ¼fen.

2. Erhebung und Analyse der Anforderungen

3. Spezifikation der Anforderungen

4. Validierung der Anforderungen

#### Ergebnisse:

- DurchfÃ¼hrbarkeitsbericht

- Systemmodelle

- Benutzer- und Systemanforderungen

- Anforderungsspezifikation

Entwurf = iterativer Prozess mit RÃ¼ckmeldungen und Korrekturen.

Phasen sind nicht strikt linear, sondern stark verknÃ¼pft.

#### Plattform und Systemtyp im Entwurfsprozess
Software hat Schnittstellen zu:

- Betriebssystemen,

- Datenbanken,

- Middleware usw.

â†’ Softwareplattform = AusfÃ¼hrungsumgebung.

Plattforminfos = wichtige Eingabe im Entwurf.

Spezifikation umfasst:

- FunktionalitÃ¤t,

- Performance- & VerlÃ¤sslichkeitsanforderungen,

- Datenbeschreibung (sofern relevant).

Systemtyp beeinflusst Entwurf:

Echtzeitsysteme â†’ Zeitverhalten wichtig.

Kein DB-Zugriff â†’ kein Datenbankentwurf nÃ¶tig.

## ğŸ“Œ V-Modell â€“ Testphasen im plangesteuerten Softwareprozess

Plangesteuerte Softwareprozesse (z.â€¯B. fÃ¼r sicherheitskritische Systeme) koppeln **jede Entwicklungsphase mit einem passenden Testplan**.

Das V-Modell zeigt:
- Links: **Spezifikation & Entwurf**
- Rechts: **zugehÃ¶rige Testphasen**
- Mitte: **Implementierung**

### ğŸ”„ Ãœbersicht â€“ Entwicklungsphasen und zugehÃ¶rige Tests

| Entwicklungsphase              | Testplan                           | Testphase                     |
|-------------------------------|------------------------------------|-------------------------------|
| Anforderungsspezifikation     | Plan fÃ¼r Abnahmetest               | **Abnahmetest**               |
| Systemspezifikation           | Plan fÃ¼r Systemintegrationstest    | **Systemintegrationstest**    |
| Systementwurf                 | Plan fÃ¼r Subsystemintegrationstest | **Subsystemintegrationstest** |
| Detailentwurf â†’ Programmierung| Modulprogrammierung und -test      | **Komponententest**           |

### ğŸ§  Merkmale

- TestplÃ¤ne werden **bereits wÃ¤hrend der Entwicklung** erstellt.
- Tests basieren **direkt auf Anforderungen & EntwÃ¼rfen**.
- Besonders relevant fÃ¼r **verlÃ¤ssliche, nachvollziehbare Prozesse**.
- Wird oft als **â€V-Modellâ€œ** bezeichnet (wegen des visuellen Ablaufs).

## ğŸ§ª Abnahme- & Betatest

- **Abnahmetest = Alphatest**  
  Wird bei individuell entwickelten Systemen durchgefÃ¼hrt, bis Entwickler und Kunde die Umsetzung fÃ¼r akzeptabel halten.

- **Betatest = Realer Nutzertest**  
  Vor Marktfreigabe testen zukÃ¼nftige Kunden die Software freiwillig im Alltag.
  - Ziel: Probleme entdecken, die Entwickler **nicht vorhersehen konnten**.
  - RÃ¼ckmeldung â†’ System wird angepasst
  - Danach: neue Betaphase oder Freigabe fÃ¼r Verkauf

---

## ğŸ”„ 2.2.4 Weiterentwicklung von Software

### ğŸ’¡ Warum Software leichter weiterentwickelt wird als Hardware:

- Software ist **flexibler**:
  - Ã„nderungen **wÃ¤hrend & nach** der Entwicklung jederzeit mÃ¶glich
  - Selbst groÃŸe Ã„nderungen gÃ¼nstiger als bei Hardware

### ğŸ•°ï¸ FrÃ¼her:
- **Trennung** zwischen Entwicklung & Wartung (â€Softwarewartungâ€œ)

### ğŸ” Heute:
- Weiterentwicklung ist **kontinuierlich integriert**  
  â†’ Software wird **von Anfang an** so geplant, dass Ã„nderungen einfach mÃ¶glich sind  
  â†’ kein starres Konzept, sondern **iteratives Anpassen**

Ein Prototyp ist keineerste Version eines Softwaresystems. Er ist in der Regel nur begrenzt ablauffÃ¤hig und soll nur die Konzepte demonstrieren.

## ğŸ§ª 2.3.1 Softwareprototypen

Ein **Prototyp** ist eine erste Version eines Softwaresystems, die genutzt wird, um:

- Konzepte zu demonstrieren
- Entwurfsideen zu testen
- Anforderungen zu klÃ¤ren
- frÃ¼hzeitig Feedback einzuholen

### âœ… Einsatzbereiche:

1. **Requirements Engineering**  
   â†’ zur Ermittlung und Validierung der Systemanforderungen

2. **Systementwurf**  
   â†’ zur Analyse von SoftwarelÃ¶sungen und zur UnterstÃ¼tzung des UI-Designs

### ğŸ¯ Vorteile:

- Benutzer erkennen frÃ¼h, wie hilfreich das System ist
- neue Anforderungen und Ideen entstehen
- SchwÃ¤chen und StÃ¤rken im Design werden sichtbar
- vergessene Anforderungen kÃ¶nnen entdeckt werden
- hilft, teures Rework spÃ¤ter zu vermeiden

## ğŸ§ª Weitere Vorteile von Prototypen

- Prototypen helfen nicht nur bei Anforderungen,  
  sondern auch beim **Vergleich von Entwurfsalternativen** und der **Machbarkeitsanalyse**.

- Beispiel: Prototyp zur PrÃ¼fung von **Datenzugriffseffizienz**

### ğŸ–¥ï¸ BenutzeroberflÃ¤che:

- Besonders nÃ¼tzlich beim UI-Design
- Textbeschreibungen reichen nicht aus
- â†’ **Rapid Prototyping** mit Einbeziehung der Endnutzer ist Pflicht

---

## ğŸ¯ Ziele der Prototypenentwicklung

- **Ziele mÃ¼ssen zu Beginn klar sein**, z.â€¯B.:
  - Erprobung der UI
  - Bewertung funktionaler Anforderungen
  - Demonstration fÃ¼r Stakeholder

- Wenn Ziele unklar â†’ MissverstÃ¤ndnisse & EnttÃ¤uschung bei Stakeholdern

ğŸ“Œ Ein Prototyp erfÃ¼llt **nicht automatisch alle Erwartungen** â€“ klare Zieldefinition ist entscheidend!

## ğŸ”„ 2.3.1 Der Vorgang der Prototypentwicklung (Abbildung 2.9)

### ğŸ§­ Schritte:

1. **Prototypziele festlegen**  
   â†’ Warum wird der Prototyp entwickelt?

2. **PrototypfunktionalitÃ¤t definieren**  
   â†’ Welche Funktionen sind enthalten? Was wird bewusst ausgelassen?

3. **Prototyp entwickeln**  
   â†’ Erstellung eines ausfÃ¼hrbaren Prototyps

4. **Prototyp auswerten**  
   â†’ Test mit Nutzern, Auswertungsbericht erstellen

---

### âœ‚ï¸ Was kann weggelassen werden?

- Nichtfunktionale Anforderungen (z.â€¯B. Reaktionszeit, Speicher)
- Fehlerbehandlung
- Anforderungen an ZuverlÃ¤ssigkeit und QualitÃ¤t

â†’ Ziel: Kosten und Aufwand bei der Prototypentwicklung senken

---

### ğŸ“Š Letzte Phase: Bewertung & Erprobung

- **Benutzerschulung notwendig**
- **Bewertungsplan erstellen**
- Benutzer testen System â†’ Feedback fÃ¼hrt zur Anpassung von Anforderungen

## âš ï¸ Risiken bei der Verwendung von Prototypen als fertiges System

### Hauptproblem:
Ein **Prototyp wird oft anders verwendet** als das fertige System:
- andere Nutzergruppen
- wenig Einarbeitungszeit
- Verhaltensanpassung an langsam reagierende Prototypen

---

### âŒ Warum die Auslieferung von Prototypen problematisch ist:

1ï¸âƒ£ **Keine BerÃ¼cksichtigung nichtfunktionaler Anforderungen**  
â†’ Leistung, Sicherheit, StabilitÃ¤t & ZuverlÃ¤ssigkeit wurden beim Prototyping vernachlÃ¤ssigt

2ï¸âƒ£ **Kaum Dokumentation & Architektur**  
â†’ Ã„nderungen flieÃŸen direkt in den Prototypcode  
â†’ Code = einzige "Spezifikation" â†’ schlecht fÃ¼r Wartung

3ï¸âƒ£ **Strukturelle Verschlechterung**  
â†’ Ã„nderungen wÃ¤hrend der Prototypentwicklung verschlechtern die Systemstruktur  
â†’ spÃ¤tere Wartung = teuer & kompliziert

## ğŸ“ Nicht-ausfÃ¼hrbare Prototypen

- Prototypen mÃ¼ssen nicht lauffÃ¤hig sein
- Papiermodelle der UI helfen beim Feedback & Design
- ğŸ’¡ **Wizard-of-Oz-Prototyp**:
  - UI ist echt, aber Eingaben werden manuell von einer Person beantwortet
  - Nutzer merkt nichts â€“ ideal zum Testen von UI-Ideen ohne funktionales Backend

---

## 2.3.2 ğŸ” Inkrementelle Auslieferung

- Ein Ansatz, bei dem das System **stÃ¼ckweise** (inkrementell) ausgeliefert wird
- Kunde entscheidet:
  - Was ist wichtig?
  - Was kann warten?
- â†’ Jedes Inkrement = ein Teilsystem / Dienst

ğŸ“Œ Dienste mit **hÃ¶chster PrioritÃ¤t** â†’ zuerst implementiert & ausgeliefert

## ğŸ” Abbildung 2.10 â€“ Inkrementelle Auslieferung

### ğŸ“Œ Ablauf:

1. Grobe Definition der Anforderungen
2. Zuordnung der Anforderungen zu Inkrementen
3. Entwurf der Systemarchitektur
4. Entwicklung eines Systeminkrements
5. Validierung des Inkrements
6. Integration des Inkrements
7. Validierung des Systems
8. Installation des Inkrements

ğŸ”„ Wenn nicht vollstÃ¤ndig â†’ nÃ¤chstes Inkrement  
âœ… Wenn vollstÃ¤ndig â†’ fertiges System

---

### âœ… Vorteile:

- FrÃ¼he Nutzung von Teilsystemen durch den Kunden
- Feedback kann direkt in spÃ¤tere Inkremente einflieÃŸen
- System wird kontinuierlich verbessert
- Anforderungen kÃ¶nnen wÃ¤hrend der Entwicklung prÃ¤zisiert werden
- Integration neuer Inkremente verbessert schrittweise die GesamtlÃ¶sung

## âš ï¸ Probleme bei der inkrementellen Entwicklung

1ï¸âƒ£ **Verteilte Kernfunktionen**  
â†’ Viele Basisfunktionen werden von mehreren Systemteilen genutzt  
â†’ Ohne vollstÃ¤ndige Anforderungen ist es schwer, sinnvolle Inkremente zu planen

2ï¸âƒ£ **Nutzererwartung: Alles oder nichts**  
â†’ Bei Ersatzsystemen wollen Nutzer die volle FunktionalitÃ¤t des alten Systems  
â†’ UnvollstÃ¤ndige Systeme werden schlecht akzeptiert â†’ kaum Feedback

3ï¸âƒ£ **Spezifikation vs. Vertragslogik**  
â†’ In vielen Unternehmen ist die vollstÃ¤ndige Spezifikation Teil des Vertrags  
â†’ Inkrementelle Entwicklung widerspricht diesem Modell  
â†’ Besonders kritisch bei GroÃŸkunden (z.â€¯B. BehÃ¶rden)

---

ğŸ“Œ Fazit: Nicht jedes Projekt eignet sich fÃ¼r inkrementelle Entwicklung  
â†’ z.â€¯B. bei Hardwarekopplung, sicherheitskritischen Systemen oder fixen VertrÃ¤gen

## ğŸŒ€ 2.3.3 Das Spiralmodell nach Boehm

- Vorgeschlagen von Barry Boehm (1988)
- Darstellung: **Spirale statt linearer Abfolge**
- Jede **Spiralschleife = eine Entwicklungsphase**

### ğŸ” Beispiel fÃ¼r Schleifen:

- Innerste: Machbarkeit analysieren
- Danach: Anforderungen definieren
- Weiter auÃŸen: Entwurf, Implementierung, Validierung usw.

---

### âœ… Vorteile des Spiralmodells:

- Kombination aus:
  - **Vermeidung von Ã„nderungen** (Planung)
  - **Toleranz fÃ¼r Ã„nderungen** (Anpassbarkeit)
- Fokus auf **Risiken**
  - Jede Phase beinhaltet **RisikomanagementaktivitÃ¤ten**
  - Ã„nderungen gelten als **Folge von Risiken**, nicht als StÃ¶rung

ğŸ“Œ Besonders geeignet fÃ¼r komplexe, risikoreiche Projekte mit vielen Unbekannten.

## ğŸ” Hauptunterschied des Spiralmodells: Risikobetrachtung

- Jeder Spiralzyklus beginnt mit der **Festlegung von Zielen**
- Danach:
  - Alternativen zur Zielerreichung definieren
  - BeschrÃ¤nkungen & Risiken identifizieren
  - Alternativen bewerten

ğŸ“Œ Methoden zur Risikoanalyse:
- Detaillierte Analysen
- Prototypen
- Simulationen

---

## ğŸ§  Was ist ein Risiko?

â†’ Etwas, das schiefgehen kann  
Beispiel: neue Sprache â†’ Compiler sind instabil oder ineffizient

---

## ğŸ“Œ Ablauf:

1. Risiken bewerten
2. Ein StÃ¼ck Software entwickeln
3. NÃ¤chste Phase planen (mit neuem Risikobewusstsein)

---

## ğŸ¯ Ziel:

- Risiken reduzieren
- Ã„nderungen frÃ¼hzeitig erkennen & absichern
- Projektprobleme (Kosten, Zeit, QualitÃ¤t) minimieren

ğŸ“š â†’ Mehr dazu in Kapitel 22 (Risikomanagement im Projekt)

## 2.4 Der Rational Unified Process (RUP)

### ğŸ”§ Was ist RUP?

- Modernes, hybrides Vorgehensmodell
- Entstanden aus der Arbeit an UML & Unified Software Development Process
- Kombiniert:
  - klassische Modelle (z.â€¯B. Wasserfall, Spiralmodell)
  - Prototyping
  - inkrementelle Auslieferung

---

## ğŸ”­ RUP = 3 Perspektiven

1ï¸âƒ£ **Dynamische Perspektive**  
â†’ zeitliche Darstellung der Projektphasen

2ï¸âƒ£ **Statische Perspektive**  
â†’ zeigt alle ProzessaktivitÃ¤ten

3ï¸âƒ£ **Praxisbezogene Perspektive**  
â†’ gibt konkrete methodische Empfehlungen pro Prozessphase

---

ğŸ“Œ Hinweis:  
Viele Quellen vermischen Perspektiven â†’ unÃ¼bersichtlich.  
Hier werden sie **separat beschrieben**, um Klarheit zu schaffen.

## ğŸ” Darstellung der RUP-Perspektiven

- Ãœblicherweise: alle Perspektiven in einer Diagrammform vereint
- Kritik: erschwert das VerstÃ¤ndnis
- LÃ¶sung: getrennte Beschreibung von:
  - dynamischer
  - statischer
  - praxisbezogener Perspektive

---

## ğŸ“Œ Phasenorientiertes Modell

- RUP unterscheidet **vier Phasen**
- Anders als beim Wasserfall:
  - Phasen â‰  ProzessaktivitÃ¤ten
  - Phasen sind **geschÃ¤ftsorientiert** (Business-Fokus)

ğŸ“Š â†’ Abbildung 2.12 zeigt die RUP-Phasen

## ğŸ”„ Die vier Phasen des RUP

1ï¸âƒ£ **Konzeption**
- Ziel: Business-Case erstellen
- Externe Akteure & Interaktionen definieren
- Beitrag des Systems bewerten
- â— Projekt kann hier abgebrochen werden

2ï¸âƒ£ **Entwurf**
- Problem verstehen & Architektur planen
- Risiken identifizieren
- Ergebnis: UML-Modelle, Architektur, Entwicklungsplan

3ï¸âƒ£ **Konstruktion**
- Programmierung & Tests (parallel & inkrementell)
- Am Ende: funktionsfÃ¤hige Software mit Dokumentation

4ï¸âƒ£ **Ãœbergabe**
- Ãœbergabe an reale Benutzerumgebung
- Schulung, EinfÃ¼hrung, Support
- Oft unterschÃ¤tzt, aber teuer & kritisch

## ğŸ”§ Praxisbezogene Perspektive im RUP â€“ empfohlene Vorgehensweisen (Teil 1)

1ï¸âƒ£ **Software iterativ entwickeln**  
â†’ Schrittweise Entwicklung nach KundenprioritÃ¤ten  
â†’ Funktionen mit hÃ¶chster PrioritÃ¤t frÃ¼hzeitig umsetzen

2ï¸âƒ£ **Anforderungen verwalten**  
â†’ Klare Dokumentation der Anforderungen  
â†’ Nachverfolgbarkeit von Ã„nderungen  
â†’ Analyse der Auswirkungen vor Umsetzung

3ï¸âƒ£ **Komponentenbasierte Architekturen verwenden**  
â†’ Architektur in wiederverwendbare Komponenten aufteilen  
â†’ Erleichtert Wartung, Skalierung und parallele Entwicklung

## ğŸ”§ Praxisbezogene Perspektive im RUP â€“ empfohlene Vorgehensweisen (Teil 2)

4ï¸âƒ£ **Software visuell modellieren**  
â†’ Einsatz von UML zur Darstellung statischer & dynamischer Aspekte

5ï¸âƒ£ **SoftwarequalitÃ¤t verifizieren**  
â†’ Sicherstellen, dass QualitÃ¤tsstandards des Unternehmens erfÃ¼llt werden

6ï¸âƒ£ **Ã„nderungen der Software steuern**  
â†’ Verwaltung von Ã„nderungen mit:
  - Ã„nderungsmanagementsystem
  - Konfigurationsmanagement
  - passender Tool-UnterstÃ¼tzung

---

## ğŸ“Œ Fazit:

- RUP ist **nicht fÃ¼r alle Projekte geeignet** (z.â€¯B. eingebettete Systeme)
- Kombiniert:
  - **Phasen (dynamisch)**
  - **ArbeitsablÃ¤ufe (statisch)**
  - **Best Practices (praxisbezogen)**
- Trennung von Phase â‰  AktivitÃ¤t:  
  AktivitÃ¤ten kÃ¶nnen phasenÃ¼bergreifend genutzt werden

